import datetime
from datetime import timedelta
import numpy as np
from cadCAD.configuration.utils import ep_time_step, config_sim

#from config import *

#Internal
avg_200 = 200
avg_250 = 250
avg_300 = 300
avg_350 = 350
avg_400 = 400



ts_format = '%Y-%m-%d %H:%M:%S'
t_delta = timedelta(days=0, minutes=0, seconds=1)
def set_time(_g, step, sL, s, _input):
    y = 'timestamp'
    x = ep_time_step(s, dt_str=s['timestamp'], fromat_str=ts_format, _timedelta=t_delta)
    return (y, x)

def random(twentieths):
    '''Returns normal random variable generated by first two central moments of price change of input ticker'''
    rv = np.random.randint(0,20)
    if rv >= twentieths:
        hit = False
    else:
        hit = True
        
    
    return hit

def AB(_g, step, sL, s):
    hit_200 = random(avg_200 / 50)
    hit_250 = random(avg_250 / 50)
    hit_300 = random(avg_300 / 50)
    hit_350 = random(avg_350 / 50)
    hit_400 = random(avg_400 / 50)
    return {'player_200': hit_200, 'player_250': hit_250, 'player_300': hit_300, 'player_350': hit_350, 'player_400': hit_400, }

def AB_200(_g,  step, sL, s, _input):
    key = 'player_200'
    value = _input['player_200']
    return key, value

def AB_250(_g,  step, sL, s, _input):
    key = 'player_250'
    value = _input['player_250']
    return key, value

def AB_300(_g,  step, sL, s, _input):
    key = 'player_300'
    value = _input['player_300']
    return key, value

def AB_350(_g,  step, sL, s, _input):
    key = 'player_350'
    value = _input['player_350']
    return key, value

def AB_400(_g,  step, sL, s, _input):
    key = 'player_400'
    value = _input['player_400']
    return key, value

# State of transmitting True for any of the 4 ABs
def game_hit_200(_g,  step, sL, s, _input):
    key = 'game_200'
    value = _input['player_200']    
    if step == 1:
#        print(step)
        return key, value
    elif s['game_200'] == False:
#        print('input',_input['player_200'], 'output', s['test_200'])
        return key, value
    else:
        return key, s['game_200']

# State of transmitting True for any of the 4 ABs
def game_hit_250(_g,  step, sL, s, _input):
    key = 'game_250'
    value = _input['player_250']    
    if step == 1:
#        print(step)
        return key, value
    elif s['game_250'] == False:
#        print('input',_input['player_250'], 'output', s['test_250'])
        return key, value
    else:
        return key, s['game_250']

# State of transmitting True for any of the 4 ABs
def game_hit_300(_g,  step, sL, s, _input):
    key = 'game_300'
    value = _input['player_300']    
    if step == 1:
#        print(step)
        return key, value
    elif s['game_300'] == False:
#        print('input',_input['player_300'], 'output', s['test_300'])
        return key, value
    else:
        return key, s['game_300']  

# State of transmitting True for any of the 4 ABs
def game_hit_350(_g,  step, sL, s, _input):
    key = 'game_350'
    value = _input['player_350']    
    if step == 1:
#        print(step)
        return key, value
    elif s['game_350'] == False:
#        print('input',_input['player_350'], 'output', s['test_350'])
        return key, value
    else:
        return key, s['game_350'] 

# State of transmitting True for any of the 4 ABs
def game_hit_400(_g,  step, sL, s, _input):
    key = 'game_400'
    value = _input['player_400']    
    if step == 1:
#        print(step)
        return key, value
    elif s['game_400'] == False:
#        print('input',_input['player_400'], 'output', s['test_400'])
        return key, value
    else:
        return key, s['game_400'] 

